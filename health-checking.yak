// =============================================================================
// YAK Services Health Checking - 服务健康检查监控系统
// 功能: 启动 HTTP 服务器，定期检查多个服务的健康状态并展示
// 用途: 服务监控、健康检查、状态展示、实时更新
//
// 核心技术栈:
// - httpserver.Serve: 启动 HTTP 服务器
// - poc.HTTP: 发起 HTTP/HTTPS 请求检查服务状态
// - json.dumps/json.loads: JSON 数据处理
// - time.Now: 时间戳记录
// - sync.Mutex: 并发安全的数据访问
//
// 使用示例:
// yak apps/health-checking/health-checking.yak --port 8080 --interval 60
//
// 应用场景: 服务监控、健康检查、状态可视化、实时监控
// 关键词: health-check monitoring httpserver poc 服务监控 健康检查
// 搜索标签: #health-check #monitoring #httpserver #service-status
// =============================================================================

// =============================================================================
// CLI 参数配置模块 - 命令行接口定义
// 功能: 定义脚本的命令行参数，支持自定义端口和检查间隔
// 技术: cli.String/Int 参数解析，cli.setDefault 默认值
//
// 参数说明:
// - port: 监控服务监听端口，默认 8080
// - interval: 健康检查间隔（秒），默认 60
// - timeout: HTTP 请求超时时间（秒），默认 10
//
// 使用示例: 
// yak health-checking.yak --port 8080 --interval 60 --timeout 10
// =============================================================================

// 服务端口配置
port = cli.Int(
    "port", 
    cli.setDefault(8080), 
    cli.setHelp("监控服务监听端口")
)

htmlDir = cli.String("html-dir", cli.setDefault("/root/yak-services-health-checking/"))

// 健康检查间隔
interval = cli.Int(
    "interval",
    cli.setDefault(60),
    cli.setHelp("健康检查间隔（秒）")
)

// HTTP 请求超时
timeout = cli.Int(
    "timeout",
    cli.setDefault(10),
    cli.setHelp("HTTP 请求超时时间（秒）")
)

// Bot 报警配置
botWebhook = cli.String(
    "bot-webhook",
    cli.setDefault(""),
    cli.setHelp("Bot webhook URL，用于发送报警通知")
)

// Mock 报警测试模式
mockAlert = cli.Bool(
    "mock-alert",
    cli.setDefault(false),
    cli.setHelp("启用 Mock 报警测试模式，添加一个必定失败的健康检查用于测试报警功能")
)

// 报警间隔配置
alertInterval = cli.Int(
    "alert-interval",
    cli.setDefault(3600),
    cli.setHelp("报警间隔时间（秒），同一服务在此时间内不会重复报警，默认3600秒（1小时）")
)

var botClient

// 验证参数
cli.check()

// 如果未指定 webhook，尝试从本地文件读取
if botWebhook == "" {
    content, err = file.ReadFile("/tmp/lark.txt")
    if err == nil {
        botWebhook = str.TrimSpace(string(content))
        log.info("Loaded webhook from /tmp/lark.txt")
    } else {
        log.info("No webhook configured (neither --bot-webhook nor /tmp/lark.txt found)")
    }
} else {
    log.info("Using webhook from command line parameter")
}

log.info("Starting YAK Services Health Checking System...")
log.info("Configuration:")
log.info("  Port: %d", port)
log.info("  Check Interval: %d seconds", interval)
log.info("  Request Timeout: %d seconds", timeout)
log.info("  Alert Interval: %d seconds (%d minutes)", alertInterval, alertInterval/60)
if botWebhook != "" {
    log.info("  Bot Webhook: %s", botWebhook)
    // 初始化 bot 客户端
    try {
        botClient = bot.New(bot.webhook(botWebhook))
        if botClient == nil {
            log.error("Failed to create bot client - returned nil")
        } else if len(botClient.Configs()) == 0 {
            log.error("Failed to initialize bot client - no configs found")
            botClient = nil
        } else {
            log.info("Bot client initialized successfully with %d config(s)", len(botClient.Configs()))
        }
    } catch err {
        log.error("Exception while initializing bot client: %v", err)
        botClient = nil
    }
} else {
    log.info("  Bot Webhook: Not configured")
}

// =============================================================================
// 服务配置模块 - 定义需要监控的服务列表
// 功能: 配置需要监控的服务，包括服务ID、名称和健康检查URL
// 技术: Map 数据结构存储服务配置
//
// 服务配置格式:
// {
//   "service_id": "服务唯一标识",
//   "service_name": "服务中文名称",
//   "service_name_en": "服务英文名称",
//   "health_url": "健康检查URL",
//   "method": "HTTP方法（默认GET）"
// }
// =============================================================================

serviceConfigs = [
    {
        "service_id": "yaklang_com",
        "service_name": "Yaklang 官网",
        "service_name_en": "Yaklang Official",
        "health_url": "https://yaklang.com",
        "expect_status": 200,
        "expect_keywords": ["Docusaurus", "Yak Program Language"]
    },
    {
        "service_id": "yaklang_io",
        "service_name": "Yaklang 国际官网",
        "service_name_en": "Yaklang International",
        "health_url": "https://yaklang.io",
        "expect_status": 200,
        "expect_keywords": ["Docusaurus", "Yak Program Language"]
    },
    {
        "service_id": "ssa_to",
        "service_name": "IRify SSA 技术官网",
        "service_name_en": "IRify SSA Official",
        "health_url": "https://ssa.to",
        "expect_status": 200,
        "expect_keywords": ["Docusaurus", "SSA-IR", "编译器级"]
    },
    {
        "service_id": "aibalance",
        "service_name": "Yaklang AI 负载均衡",
        "service_name_en": "Yaklang AI Balance",
        "health_url": "https://aibalance.yaklang.com",
        "expect_status": 200,
        "expect_keywords": ["AI Balance", "Orbitron"]
    },
    {
        "service_id": "codescan_ssa",
        "service_name": "SSA 代码扫描",
        "service_name_en": "SSA Code Scan",
        "health_url": "https://codescan.ssa.to",
        "expect_status": 404,
        "expect_keywords": ["404", "not found"]
    },
    {
        "service_id": "embedding_service",
        "service_name": "YAK Embedding Service",
        "service_name_en": "YAK Embedding Service",
        "health_url": "https://embedding.yaklang.com",
        "expect_status": 404,
        "expect_keywords": ["invalid_request_error"]
    },
]

// 如果启用了 Mock 报警测试模式，添加一个必定失败的服务
if mockAlert {
    mockService = {
        "service_id": "mock_alert_test",
        "service_name": "Mock 报警测试服务",
        "service_name_en": "Mock Alert Test Service",
        "health_url": "http://mock-alert-test-non-existent-domain-12345.invalid",
        "expect_status": 200,
        "expect_keywords": ["success"]
    }
    serviceConfigs = append(serviceConfigs, mockService)
    log.info("Mock alert mode enabled, added test failure service")
}

log.info("Configured %d services for monitoring", len(serviceConfigs))

// =============================================================================
// 健康状态数据存储模块 - 线程安全的状态管理
// 功能: 存储和管理所有服务的健康状态数据
// 技术: sync.NewMutex 创建互斥锁，保证并发安全
//
// 数据结构:
// [
//   {
//     "service_id": "aibalance",
//     "service_name": "AI均衡器",
//     "service_name_en": "AI Balance",
//     "status_code": 200,
//     "response": "响应内容摘要",
//     "updated_at": "2024-01-01T12:00:00Z"
//   }
// ]
// =============================================================================

healthData = []
healthDataMutex = sync.NewMutex()

// 报警状态跟踪 - 基于时间的报警频率控制
alertedServices = {}  // 已报警的服务及其最后报警时间 {"service_id": timestamp}
alertedServicesMutex = sync.NewMutex()

log.info("Initialized health data storage with mutex lock")

// =============================================================================
// 健康检查执行模块 - 检查单个服务的健康状态
// 功能: 向指定服务发送 HTTP 请求，获取健康状态
// 技术: poc.HTTP 发起请求，poc.GetStatusCodeFromResponse 获取状态码
//
// 参数:
// - config: 服务配置对象
//
// 返回:
// - 服务健康状态对象
// =============================================================================

checkServiceHealth = func(config) {
    log.info("Checking health for service: %s", config["service_id"])
    
    serviceId = config["service_id"]
    serviceName = config["service_name"]
    serviceNameEn = config["service_name_en"]
    healthUrl = config["health_url"]
    expectStatus = config["expect_status"] || 200
    expectKeywords = config["expect_keywords"] || []
    
    // 构建健康状态对象
    healthStatus = {
        "service_id": serviceId,
        "service_name": serviceName,
        "service_name_en": serviceNameEn,
        "status_code": 0,
        "response": "",
        "is_healthy": false,
        "check_detail": "",
        "updated_at": time.Now().Format("2006-01-02T15:04:05Z07:00")
    }
    
    log.info("Sending GET request to %s", healthUrl)
    
    // 发起请求
    try {
        packet = f`GET ${healthUrl} HTTP/1.1
Host: auto
User-Agent: YAK-Health-Checker/1.0

`
        
        rsp, req, err = poc.HTTP(packet, poc.timeout(timeout))
        
        if err != nil {
            log.error("HTTP request failed for %s: %v", serviceId, err)
            healthStatus["response"] = f"Request error: ${err}"
            healthStatus["check_detail"] = f"Network error: ${err}"
            return healthStatus
        }
        
        // 获取状态码
        statusCode = poc.GetStatusCodeFromResponse(rsp)
        healthStatus["status_code"] = statusCode
        
        // 获取完整响应体用于关键字检查
        _, body = poc.Split(rsp)
        bodyStr = string(body)
        fullBody = bodyStr
        
        // 存储简短响应
        if len(bodyStr) > 200 {
            bodyStr = bodyStr[:200] + "..."
        }
        healthStatus["response"] = bodyStr
        
        // 验证状态码
        statusMatch = (statusCode == expectStatus)
        
        // 验证关键字
        keywordMatch = true
        matchedKeywords = []
        if len(expectKeywords) > 0 {
            for keyword in expectKeywords {
                if str.Contains(fullBody, keyword) {
                    matchedKeywords = append(matchedKeywords, keyword)
                }
            }
            keywordMatch = (len(matchedKeywords) > 0)
        }
        
        // 判断整体健康状态
        healthStatus["is_healthy"] = (statusMatch && keywordMatch)
        
        // 构建检查详情
        if healthStatus["is_healthy"] {
            healthStatus["check_detail"] = f"Status: ${statusCode} (expected ${expectStatus}), Keywords matched: ${len(matchedKeywords)}/${len(expectKeywords)}"
        } else {
            if !statusMatch {
                healthStatus["check_detail"] = f"Status mismatch: got ${statusCode}, expected ${expectStatus}"
            } else {
                healthStatus["check_detail"] = f"Keywords missing: matched ${len(matchedKeywords)}/${len(expectKeywords)}"
            }
        }
        
        log.info("Health check completed for %s: healthy=%v, status=%d", serviceId, healthStatus["is_healthy"], statusCode)
        
    } catch err {
        log.error("Exception during health check for %s: %v", serviceId, err)
        healthStatus["response"] = f"Exception: ${err}"
        healthStatus["check_detail"] = f"Exception: ${err}"
    }
    
    return healthStatus
}

// =============================================================================
// 报警功能模块 - 发送健康状态报警
// 功能: 当服务不健康时发送报警通知，避免重复报警
// 技术: 使用互斥锁保证线程安全，bot 客户端发送通知
// 注意: 这些函数将在 botClient 初始化后重新定义
// =============================================================================

// 发送健康报警
sendHealthAlert = func(healthStatus) {
    log.info("sendHealthAlert called for service %s", healthStatus["service_id"])
    if botClient == nil {
        log.info("Bot client not configured, skipping alert for service %s", healthStatus["service_id"])
        return  // 未配置 bot 客户端
    }
    
    log.info("Processing alert for service %s", healthStatus["service_id"])

    serviceId = healthStatus["service_id"]
    currentTime = time.Now().Unix()

    // 检查是否在报警间隔内
    alertedServicesMutex.Lock()
    shouldAlert = true
    lastAlertTime = 0
    if serviceId in alertedServices {
        lastAlertTime = alertedServices[serviceId]
        shouldAlert = (currentTime - lastAlertTime >= alertInterval)
    }
    alertedServicesMutex.Unlock()

    if !shouldAlert {
        timeSinceLastAlert = currentTime - lastAlertTime
        remainingTime = alertInterval - timeSinceLastAlert
        log.info("Alert cooldown for service %s: %d seconds remaining", serviceId, remainingTime)
        return
    }

    // 记录本次报警时间
    alertedServicesMutex.Lock()
    alertedServices[serviceId] = currentTime
    alertedServicesMutex.Unlock()

    // 生成报警消息
    hostname, err = os.Hostname()
    if err != nil {
        hostname = "unknown"
    }

    alertTime = time.Now().Format("2006-01-02 15:04:05")

    markdown = sprintf(`🚨 服务健康检查报警

## ⚠️ 服务异常
- **服务名称**: %s
- **服务ID**: %s
- **检查URL**: %s
- **主机**: %s
- **时间**: %s

## 📊 检查结果
- **状态码**: %d
- **健康状态**: ❌ 不健康
- **检查详情**: %s

## 🔍 响应内容
%s

---
*请及时检查服务状态*
`, healthStatus["service_name"], healthStatus["service_id"], healthStatus["service_name_en"],
   hostname, alertTime, healthStatus["status_code"], healthStatus["check_detail"], healthStatus["response"])

    // 发送报警
    try {
        botClient.SendMarkdown(markdown)
        log.info("Health alert sent for service: %s", serviceId)
    } catch err {
        log.error("Failed to send health alert for service %s: %v", serviceId, err)
    }

    // 发送简单文本报警（备用）
    simpleMessage = sprintf("🚨 报警: %s (%s) 服务异常 - 状态码:%d - %s",
        healthStatus["service_name"], healthStatus["service_id"],
        healthStatus["status_code"], alertTime)

    try {
        botClient.SendText(simpleMessage)
    } catch err {
        log.error("Failed to send simple alert text for service %s: %v", serviceId, err)
    }
}

// 发送服务恢复通知
sendRecoveryNotification = func(healthStatus) {
    if botClient == nil {
        return
    }
    
    log.info("Sending recovery notification for service: %s", healthStatus["service_id"])
    
    // 生成恢复通知消息
    hostname, err = os.Hostname()
    if err != nil {
        hostname = "unknown"
    }
    
    recoveryTime = time.Now().Format("2006-01-02 15:04:05")
    
    markdown = sprintf(`✅ 服务恢复通知

## 🎉 服务已恢复正常
- **服务名称**: %s
- **服务ID**: %s
- **检查URL**: %s
- **主机**: %s
- **恢复时间**: %s

## 📊 当前状态
- **状态码**: %d
- **健康状态**: ✅ 正常
- **检查详情**: %s

---
*服务已恢复正常运行*
`, healthStatus["service_name"], healthStatus["service_id"], healthStatus["service_name_en"],
   hostname, recoveryTime, healthStatus["status_code"], healthStatus["check_detail"])

    // 发送恢复通知
    try {
        botClient.SendMarkdown(markdown)
        log.info("Recovery notification sent for service: %s", healthStatus["service_id"])
    } catch err {
        log.error("Failed to send recovery notification for service %s: %v", healthStatus["service_id"], err)
    }

    // 发送简单文本通知（备用）
    simpleMessage = sprintf("✅ 恢复: %s (%s) 服务已恢复正常 - 状态码:%d - %s",
        healthStatus["service_name"], healthStatus["service_id"],
        healthStatus["status_code"], recoveryTime)

    try {
        botClient.SendText(simpleMessage)
    } catch err {
        log.error("Failed to send simple recovery text for service %s: %v", healthStatus["service_id"], err)
    }
}

// 清除报警状态（服务恢复时调用）
clearAlertStatus = func(serviceId, healthStatus) {
    alertedServicesMutex.Lock()
    wasAlerted = serviceId in alertedServices
    if wasAlerted {
        delete(alertedServices, serviceId)
        log.info("Cleared alert status for service: %s", serviceId)
    }
    alertedServicesMutex.Unlock()
    
    // 如果之前有报警，现在恢复了，发送恢复通知
    if wasAlerted && botClient != nil {
        sendRecoveryNotification(healthStatus)
    }
}

// =============================================================================
// 批量健康检查模块 - 检查所有配置的服务
// 功能: 遍历所有服务配置，执行健康检查并更新状态
// 技术: 并发执行检查，使用互斥锁更新共享数据
// =============================================================================

performHealthChecks = func() {
    log.info("Starting batch health check for %d services", len(serviceConfigs))
    currentTime = time.Now().Format("2006-01-02 15:04:05")
    println(f"\n[${currentTime}] 开始健康检查...")
    
    newHealthData = []
    
    // 遍历所有服务配置
    for config in serviceConfigs {
        healthStatus = checkServiceHealth(config)
        newHealthData = append(newHealthData, healthStatus)

        // 输出检查结果
        statusIcon = "✓"
        if !healthStatus["is_healthy"] {
            statusIcon = "✗"
        }
        println(f"  ${statusIcon} ${healthStatus['service_name']} (${healthStatus['service_id']}): ${healthStatus['check_detail']}")

        // 报警逻辑
        if !healthStatus["is_healthy"] {
            log.info("Service %s is unhealthy, attempting to send alert", healthStatus["service_id"])
            sendHealthAlert(healthStatus)
        } else {
            // 服务恢复健康时，清除报警状态
            clearAlertStatus(healthStatus["service_id"], healthStatus)
        }
    }
    
    // 使用互斥锁更新健康数据
    healthDataMutex.Lock()
    healthData = newHealthData
    healthDataMutex.Unlock()
    
    log.info("Batch health check completed")
    println("健康检查完成\n")
}

// =============================================================================
// 定时健康检查模块 - 后台定时执行健康检查
// 功能: 在后台启动定时任务，定期检查服务健康状态
// 技术: go fn{} 启动协程，sleep 控制间隔
// =============================================================================

startHealthCheckScheduler = func() {
    log.info("Starting health check scheduler (interval: %d seconds)", interval)
    
    // 等待 botClient 初始化完成
    sleep(1)
    
    // 启动时立即执行一次检查
    performHealthChecks()
    
    // 后台定时执行
    go fn {
        for {
            sleep(interval)
            performHealthChecks()
        }
    }
    
    log.info("Health check scheduler started")
}

// =============================================================================
// HTTP 服务器模块 - 启动 Web 服务提供健康状态展示
// 功能: 启动 HTTP 服务器，提供 HTML 界面和 JSON API
// 技术: httpserver.Serve 启动服务，httpserver.handler 设置处理函数
//
// API 端点:
// - GET / - 返回 HTML 健康状态展示页面
// - GET /health.json - 返回 JSON 格式的健康状态数据
//
// 响应格式:
// [
//   {
//     "service_id": "aibalance",
//     "service_name": "AI均衡器",
//     "service_name_en": "AI Balance",
//     "status_code": 200,
//     "response": "...",
//     "updated_at": "2024-01-01T12:00:00Z"
//   }
// ]
// =============================================================================

startHTTPServer = func() {
    log.info("Starting HTTP server on 0.0.0.0:%d", port)
    
    pwd = os.Getwd()~

    // 读取 HTML 文件（尝试多个可能的路径）
    possiblePaths = [
        "apps/health-checking/index.html",
        "index.html",
        "./index.html",
        file.Join(pwd, "root", "yak-services-health-checking", `index.html`),
        file.Join(htmlDir, `index.html`),
    ]
    
    htmlContent = []
    htmlLoaded = false
    
    for htmlPath in possiblePaths {
        content, readErr = file.ReadFile(htmlPath)
        if readErr == nil {
            htmlContent = content
            htmlLoaded = true
            log.info("HTML file loaded from: %s", htmlPath)
            break
        }
    }
    
    if !htmlLoaded {
        log.error("Failed to load HTML file from any path")
        die("Failed to load HTML file")
    }
    
    // 启动 HTTP 服务器
    go fn {
        err = httpserver.Serve("0.0.0.0", port, httpserver.handler((rsp, req) => {
            log.info("Received request: %s %s from %s", req.Method, req.URL.Path, req.RemoteAddr)
            
            // 处理不同的路径
            if req.URL.Path == "/" || req.URL.Path == "/index.html" {
                // 返回 HTML 页面
                log.info("Serving HTML page to %s", req.RemoteAddr)
                rsp.Header().Set("Content-Type", "text/html; charset=utf-8")
                rsp.WriteHeader(200)
                rsp.Write(htmlContent)
                
            } else if req.URL.Path == "/health.json" {
                // 返回 JSON 数据
                log.info("Serving health JSON to %s", req.RemoteAddr)
                
                // 使用互斥锁读取健康数据
                healthDataMutex.Lock()
                currentData = healthData
                healthDataMutex.Unlock()
                
                // 序列化为 JSON
                jsonData = json.dumps(currentData)
                
                rsp.Header().Set("Content-Type", "application/json; charset=utf-8")
                rsp.Header().Set("Access-Control-Allow-Origin", "*")
                rsp.WriteHeader(200)
                rsp.Write(jsonData)
                
            } else {
                // 404 Not Found
                log.warn("Path not found: %s", req.URL.Path)
                rsp.WriteHeader(404)
                rsp.Write(b`{"error": "Not Found"}`)
            }
        }))
        
        if err != nil {
            log.error("Failed to start HTTP server: %v", err)
            die(f"Failed to start HTTP server: ${err}")
        }
    }
    
    // 等待服务器启动
    sleep(1)
    
    log.info("HTTP server started successfully")
}

// =============================================================================
// 主程序入口
// =============================================================================

println("\n" + "=" * 60)
println("YAK Services Health Checking System")
println("=" * 60)

// 启动定时健康检查
startHealthCheckScheduler()

// 启动 HTTP 服务器
startHTTPServer()

println(f"\n✓ 健康检查服务已启动")
println(f"✓ 监控服务数量: ${len(serviceConfigs)}")
println(f"✓ 检查间隔: ${interval} 秒")
println(f"✓ Web 界面: http://0.0.0.0:${port}")
println(f"✓ JSON API: http://0.0.0.0:${port}/health.json")
println("\n服务正在运行中，按 Ctrl+C 停止")
println("=" * 60 + "\n")

// 保持脚本运行
for {
    sleep(1)
}

